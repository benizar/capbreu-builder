load.landSchema <- function(x){
##LOAD YAML
yaml<-yaml.load_file(x)
#LOAD METADATA
structure <- yaml$Structure
title <- yaml$Title
description <- yaml$Description
landmetrics <- unlist(yaml$Landmetrics)
aggregation_levels <- unlist(yaml$Aggregations)
##LOAD SPATIAL DATA
spatial_data <- lapply(yaml$Spatial_data, function(x) {readOGR(dsn=x, layer=ogrListLayers(x))})
spatial_data <- setNames(spatial_data,basename(yaml$Spatial_data))
##LOAD DATA
##Unlist the elements of the yaml
bigTable <- lapply(yaml$Landholders, function(x){ unlist(x)})
##Convert it to a data frame
bigTable <- rbind.fill(lapply(bigTable, function(x) do.call("data.frame", as.list(x))))
##Transpose the data frame
#TODO: REVISAR - Warning message:attributes are not identical across measure variables; they will be dropped
bigTable <- melt(bigTable, id=c("Landholder"))
##Sort by name
bigTable <- bigTable[order(bigTable$Landholder),]
##Complete cases to remove rows with NA values BUT,NULL GUESSINGS ARE REMOVED TOO!!!
bigTable <- bigTable[complete.cases(bigTable),]
##Split Reshape2 variable into "relation_type"."detail"
bigTable <- data.frame(bigTable$Landholder, bigTable$variable, do.call('rbind', strsplit(as.character(bigTable$variable),'.',fixed=TRUE)), bigTable$value)
##Replace 'Plots' introduced by variable recycling by 0 index
levels(bigTable$X4) <- c(levels(bigTable$X4), 0)
bigTable$X4[bigTable$X4 == 'Plots'] <- 0
##Plot to plot index
bigTable$X4 <- paste(bigTable$bigTable.Landholder,bigTable$X4, sep = '-')
##Replace numbered variables
##NeighboursX by "Neighbour"
levels(bigTable$X3) <- c(levels(bigTable$X3), 'Neighbour')
bigTable$X3[grepl("Neigh",bigTable$X3)] <- 'Neighbour'
##NaturalX by "Natural"
levels(bigTable$X3) <- c(levels(bigTable$X3), 'Natural')
bigTable$X3[grepl("Natur",bigTable$X3)] <- 'Natural'
##AnthropicX by "Anthropic"
levels(bigTable$X3) <- c(levels(bigTable$X3), 'Anthropic')
bigTable$X3[grepl("Anthro",bigTable$X3)] <- 'Anthropic'
##AdministrativeX by "Administrative"
levels(bigTable$X3) <- c(levels(bigTable$X3), 'Administrative')
bigTable$X3[grepl("Admin",bigTable$X3)] <- 'Administrative'
##bigTable dataframe and names
bigTable<-data.frame(bigTable$bigTable.Landholder,bigTable$X2,bigTable$X3,bigTable$X4,bigTable$bigTable.value)
names(bigTable)[1] <- "Landholder"
names(bigTable)[2] <- "VarCategory"
names(bigTable)[3] <- "Variable"
names(bigTable)[4] <- "Plot"
names(bigTable)[5] <- "Value"
##Append a landholder-based index to the Big Table
LandholderId<-as.numeric(bigTable$Landholder)
bigTable<-cbind(LandholderId, bigTable)
##Resulting named list
result <- setNames(list(
structure,title,description,landmetrics,aggregation_levels,spatial_data,bigTable),
c("structure","title","description","landmetrics","aggregation_levels","spatial_data","bigTable"))
return(result)
}
cabreve <- load.landSchema("C:\\Users\\benizar\\Dropbox\\article_cabreve\\load_data\\capbreu_load_tests.yml")
cabreve <- load.landSchema("C:\Users\benizar\Dropbox\article_cabreve\load_data\capbreu_load_tests_windows.yml")
cabreve <- load.landSchema("C:\\Users\\benizar\\Dropbox\\article_cabreve\\load_data\\capbreu_load_tests_windows.yml")
bigTable<-cabreve$bigTable
aggregations<-bigTable[bigTable$VarCategory != 'Limits', ]
aggregations<-dcast(land_aggregations,Landholder+Plot~Variable,value.var = "Value")
aggregations<-dcast(aggregations,Landholder+Plot~Variable,value.var = "Value")
View(aggregations)
aggregations$Area<-as.integer(aggregations$Area)
aggregations$Area<-as.numeric(aggregations$Area)
View(aggregations)
conversion<-cabreve$landmetrics
conversion
conversion<-as.list(cabreve$landmetrics)
library(yaml)
library(plyr)
library(reshape2)
library(rgdal)
load.landSchema <- function(x){
##LOAD YAML
yaml<-yaml.load_file(x)
#LOAD METADATA
structure <- yaml$Structure
title <- yaml$Title
description <- yaml$Description
landmetrics <- yaml$Landmetrics
aggregation_levels <- unlist(yaml$Aggregations)
##LOAD SPATIAL DATA
spatial_data <- lapply(yaml$Spatial_data, function(x) {readOGR(dsn=x, layer=ogrListLayers(x))})
spatial_data <- setNames(spatial_data,basename(yaml$Spatial_data))
##LOAD DATA
##Unlist the elements of the yaml
bigTable <- lapply(yaml$Landholders, function(x){ unlist(x)})
##Convert it to a data frame
bigTable <- rbind.fill(lapply(bigTable, function(x) do.call("data.frame", as.list(x))))
##Transpose the data frame
#TODO: REVISAR - Warning message:attributes are not identical across measure variables; they will be dropped
bigTable <- melt(bigTable, id=c("Landholder"))
##Sort by name
bigTable <- bigTable[order(bigTable$Landholder),]
##Complete cases to remove rows with NA values BUT,NULL GUESSINGS ARE REMOVED TOO!!!
bigTable <- bigTable[complete.cases(bigTable),]
##Split Reshape2 variable into "relation_type"."detail"
bigTable <- data.frame(bigTable$Landholder, bigTable$variable, do.call('rbind', strsplit(as.character(bigTable$variable),'.',fixed=TRUE)), bigTable$value)
##Replace 'Plots' introduced by variable recycling by 0 index
levels(bigTable$X4) <- c(levels(bigTable$X4), 0)
bigTable$X4[bigTable$X4 == 'Plots'] <- 0
##Plot to plot index
bigTable$X4 <- paste(bigTable$bigTable.Landholder,bigTable$X4, sep = '-')
##Replace numbered variables
##NeighboursX by "Neighbour"
levels(bigTable$X3) <- c(levels(bigTable$X3), 'Neighbour')
bigTable$X3[grepl("Neigh",bigTable$X3)] <- 'Neighbour'
##NaturalX by "Natural"
levels(bigTable$X3) <- c(levels(bigTable$X3), 'Natural')
bigTable$X3[grepl("Natur",bigTable$X3)] <- 'Natural'
##AnthropicX by "Anthropic"
levels(bigTable$X3) <- c(levels(bigTable$X3), 'Anthropic')
bigTable$X3[grepl("Anthro",bigTable$X3)] <- 'Anthropic'
##AdministrativeX by "Administrative"
levels(bigTable$X3) <- c(levels(bigTable$X3), 'Administrative')
bigTable$X3[grepl("Admin",bigTable$X3)] <- 'Administrative'
##bigTable dataframe and names
bigTable<-data.frame(bigTable$bigTable.Landholder,bigTable$X2,bigTable$X3,bigTable$X4,bigTable$bigTable.value)
names(bigTable)[1] <- "Landholder"
names(bigTable)[2] <- "VarCategory"
names(bigTable)[3] <- "Variable"
names(bigTable)[4] <- "Plot"
names(bigTable)[5] <- "Value"
##Append a landholder-based index to the Big Table
LandholderId<-as.numeric(bigTable$Landholder)
bigTable<-cbind(LandholderId, bigTable)
##Resulting named list
result <- setNames(list(
structure,title,description,landmetrics,aggregation_levels,spatial_data,bigTable),
c("structure","title","description","landmetrics","aggregation_levels","spatial_data","bigTable"))
return(result)
}
cabreve <- load.landSchema("C:\\Users\\benizar\\Dropbox\\article_cabreve\\load_data\\capbreu_load_tests_windows.yml")
conversion<-cabreve$landmetrics
cabreve <- load.landSchema("C:\\Users\\benizar\\Dropbox\\article_cabreve\\load_data\\capbreu_load_tests_windows.yml")
bigTable<-cabreve$bigTable
conversion<-cabreve$landmetrics
library(yaml)
library(plyr)
library(reshape2)
library(rgdal)
load.landSchema <- function(x){
##LOAD YAML
yaml<-yaml.load_file(x)
#LOAD METADATA
structure <- yaml$Structure
title <- yaml$Title
description <- yaml$Description
landmetrics <- unlist(yaml$Landmetrics)
aggregation_levels <- unlist(yaml$Aggregations)
##LOAD SPATIAL DATA
spatial_data <- lapply(yaml$Spatial_data, function(x) {readOGR(dsn=x, layer=ogrListLayers(x))})
spatial_data <- setNames(spatial_data,basename(yaml$Spatial_data))
##LOAD DATA
##Unlist the elements of the yaml
bigTable <- lapply(yaml$Landholders, function(x){ unlist(x)})
##Convert it to a data frame
bigTable <- rbind.fill(lapply(bigTable, function(x) do.call("data.frame", as.list(x))))
##Transpose the data frame
#TODO: REVISAR - Warning message:attributes are not identical across measure variables; they will be dropped
bigTable <- melt(bigTable, id=c("Landholder"))
##Sort by name
bigTable <- bigTable[order(bigTable$Landholder),]
##Complete cases to remove rows with NA values BUT,NULL GUESSINGS ARE REMOVED TOO!!!
bigTable <- bigTable[complete.cases(bigTable),]
##Split Reshape2 variable into "relation_type"."detail"
bigTable <- data.frame(bigTable$Landholder, bigTable$variable, do.call('rbind', strsplit(as.character(bigTable$variable),'.',fixed=TRUE)), bigTable$value)
##Replace 'Plots' introduced by variable recycling by 0 index
levels(bigTable$X4) <- c(levels(bigTable$X4), 0)
bigTable$X4[bigTable$X4 == 'Plots'] <- 0
##Plot to plot index
bigTable$X4 <- paste(bigTable$bigTable.Landholder,bigTable$X4, sep = '-')
##Replace numbered variables
##NeighboursX by "Neighbour"
levels(bigTable$X3) <- c(levels(bigTable$X3), 'Neighbour')
bigTable$X3[grepl("Neigh",bigTable$X3)] <- 'Neighbour'
##NaturalX by "Natural"
levels(bigTable$X3) <- c(levels(bigTable$X3), 'Natural')
bigTable$X3[grepl("Natur",bigTable$X3)] <- 'Natural'
##AnthropicX by "Anthropic"
levels(bigTable$X3) <- c(levels(bigTable$X3), 'Anthropic')
bigTable$X3[grepl("Anthro",bigTable$X3)] <- 'Anthropic'
##AdministrativeX by "Administrative"
levels(bigTable$X3) <- c(levels(bigTable$X3), 'Administrative')
bigTable$X3[grepl("Admin",bigTable$X3)] <- 'Administrative'
##bigTable dataframe and names
bigTable<-data.frame(bigTable$bigTable.Landholder,bigTable$X2,bigTable$X3,bigTable$X4,bigTable$bigTable.value)
names(bigTable)[1] <- "Landholder"
names(bigTable)[2] <- "VarCategory"
names(bigTable)[3] <- "Variable"
names(bigTable)[4] <- "Plot"
names(bigTable)[5] <- "Value"
##Append a landholder-based index to the Big Table
LandholderId<-as.numeric(bigTable$Landholder)
bigTable<-cbind(LandholderId, bigTable)
##Resulting named list
result <- setNames(list(
structure,title,description,landmetrics,aggregation_levels,spatial_data,bigTable),
c("structure","title","description","landmetrics","aggregation_levels","spatial_data","bigTable"))
return(result)
}
cabreve <- load.landSchema("C:\\Users\\benizar\\Dropbox\\article_cabreve\\load_data\\capbreu_load_tests_windows.yml")
bigTable<-cabreve$bigTable
conversion<-cabreve$landmetrics
conversion[1]
conversion[2]
Area_unit<-conversion[1]
Area_conv<-conversion[2]
aggregations$Area_m2<-aggregations$Area*Area_conv
Area_unit<-conversion[1]
Area_conv<-as.numeric(conversion[2])
aggregations$Area_m2<-aggregations$Area*Area_conv
Area_unit<-as.character(conversion[1])
View(aggregations)
aggregations$Area<-as.numeric(aggregations$Area)
View(aggregations)
View(bigTable)
yaml<-yaml.load_file("C:\\Users\\benizar\\Dropbox\\article_cabreve\\load_data\\capbreu_load_tests_windows.yml")
yaml<-yaml.load_file("C:\\Users\\benizar\\Dropbox\\article_cabreve\\load_data\\capbreu_load_tests_windows.yml", handlers=list("float#fix"=function(x) as.character(x))))
yaml<-yaml.load_file("C:\\Users\\benizar\\Dropbox\\article_cabreve\\load_data\\capbreu_load_tests_windows.yml", handlers=list("float#fix"=function(x) as.character(x)))
cabreve <- load.landSchema("C:\\Users\\benizar\\Dropbox\\article_cabreve\\load_data\\capbreu_load_tests_windows.yml")
bigTable<-cabreve$bigTable
View(bigTable)
Area_unit<-as.character(conversion[1])
Area_conv<-as.numeric(conversion[2])
aggregations<-bigTable[bigTable$VarCategory != 'Limits', ]
aggregations<-dcast(aggregations,Landholder+Plot~Variable,value.var = "Value")
View(aggregations)
cabreve <- load.landSchema("C:\\Users\\benizar\\Dropbox\\article_cabreve\\load_data\\capbreu_load_tests_windows.yml")
bigTable<-cabreve$bigTable
conversion<-cabreve$landmetrics
Area_unit<-as.character(conversion[1])
Area_conv<-as.numeric(conversion[2])
View(aggregations)
yaml$Landholders
kk<-yaml$Landholders
as.data.frame(kk)
cabreve <- load.landSchema("C:\\Users\\benizar\\Dropbox\\article_cabreve\\load_data\\capbreu_load_tests_windows.yml")
bigTable<-cabreve$bigTable
conversion<-cabreve$landmetrics
Area_unit<-as.character(conversion[1])
Area_conv<-as.numeric(conversion[2])
View(bigTable)
View(aggregations)
cabreve <- load.landSchema("C:\\Users\\benizar\\Dropbox\\article_cabreve\\load_data\\capbreu_load_tests_windows.yml")
bigTable<-cabreve$bigTable
conversion<-cabreve$landmetrics
Area_unit<-as.character(conversion[1])
Area_conv<-as.numeric(conversion[2])
View(aggregations)
library(yaml)
library(plyr)
library(reshape2)
library(rgdal)
load.landSchema <- function(x){
##LOAD YAML
yaml<-yaml.load_file(x)
#LOAD METADATA
structure <- yaml$Structure
title <- yaml$Title
description <- yaml$Description
landmetrics <- unlist(yaml$Landmetrics)
aggregation_levels <- unlist(yaml$Aggregations)
##LOAD SPATIAL DATA
spatial_data <- lapply(yaml$Spatial_data, function(x) {readOGR(dsn=x, layer=ogrListLayers(x))})
spatial_data <- setNames(spatial_data,basename(yaml$Spatial_data))
##LOAD DATA
##Unlist the elements of the yaml
bigTable <- lapply(yaml$Landholders, function(x){ unlist(x)})
##Convert it to a data frame
bigTable <- rbind.fill(lapply(bigTable, function(x) do.call("data.frame", as.list(x))))
##Transpose the data frame
#TODO: REVISAR - Warning message:attributes are not identical across measure variables; they will be dropped
bigTable <- melt(bigTable, id=c("Landholder"))
##Sort by name
bigTable <- bigTable[order(bigTable$Landholder),]
##Complete cases to remove rows with NA values BUT,NULL GUESSINGS ARE REMOVED TOO!!!
bigTable <- bigTable[complete.cases(bigTable),]
##Split Reshape2 variable into "relation_type"."detail"
bigTable <- data.frame(bigTable$Landholder, bigTable$variable, do.call('rbind', strsplit(as.character(bigTable$variable),'.',fixed=TRUE)), bigTable$value)
##Replace 'Plots' introduced by variable recycling by 0 index
levels(bigTable$X4) <- c(levels(bigTable$X4), 0)
bigTable$X4[bigTable$X4 == 'Plots'] <- 0
##Plot to plot index
bigTable$X4 <- paste(bigTable$bigTable.Landholder,bigTable$X4, sep = '-')
##Replace numbered variables
##NeighboursX by "Neighbour"
levels(bigTable$X3) <- c(levels(bigTable$X3), 'Neighbour')
bigTable$X3[grepl("Neigh",bigTable$X3)] <- 'Neighbour'
##NaturalX by "Natural"
levels(bigTable$X3) <- c(levels(bigTable$X3), 'Natural')
bigTable$X3[grepl("Natur",bigTable$X3)] <- 'Natural'
##AnthropicX by "Anthropic"
levels(bigTable$X3) <- c(levels(bigTable$X3), 'Anthropic')
bigTable$X3[grepl("Anthro",bigTable$X3)] <- 'Anthropic'
##AdministrativeX by "Administrative"
levels(bigTable$X3) <- c(levels(bigTable$X3), 'Administrative')
bigTable$X3[grepl("Admin",bigTable$X3)] <- 'Administrative'
##bigTable dataframe and names
bigTable<-data.frame(bigTable$bigTable.Landholder,bigTable$X2,bigTable$X3,bigTable$X4,bigTable$bigTable.value)
names(bigTable)[1] <- "Landholder"
names(bigTable)[2] <- "VarCategory"
names(bigTable)[3] <- "Variable"
names(bigTable)[4] <- "Plot"
names(bigTable)[5] <- "Value"
##Append a landholder-based index to the Big Table
LandholderId<-as.numeric(bigTable$Landholder)
bigTable<-cbind(LandholderId, bigTable)
##Resulting named list
result <- setNames(list(
structure,title,description,landmetrics,aggregation_levels,spatial_data,bigTable),
c("structure","title","description","landmetrics","aggregation_levels","spatial_data","bigTable"))
return(result)
}
cabreve <- load.landSchema("C:\\Users\\benizar\\Dropbox\\article_cabreve\\load_data\\capbreu_load_tests_windows.yml")
bigTable<-cabreve$bigTable
conversion<-cabreve$landmetrics
Area_unit<-as.character(conversion[1])
Area_conv<-as.numeric(conversion[2])
View(aggregations)
cabreve <- load.landSchema("C:\\Users\\benizar\\Dropbox\\article_cabreve\\load_data\\capbreu_load_tests_windows.yml")
bigTable<-cabreve$bigTable
conversion<-cabreve$landmetrics
Area_unit<-as.character(conversion[1])
Area_conv<-as.numeric(conversion[2])
View(aggregations)
cabreve <- load.landSchema("C:\\Users\\benizar\\Dropbox\\article_cabreve\\load_data\\capbreu_load_tests_windows.yml")
bigTable<-cabreve$bigTable
conversion<-cabreve$landmetrics
Area_unit<-as.character(conversion[1])
Area_conv<-as.numeric(conversion[2])
View(aggregations)
cabreve <- load.landSchema("C:\\Users\\benizar\\Dropbox\\article_cabreve\\load_data\\capbreu_load_tests_windows.yml")
bigTable<-cabreve$bigTable
conversion<-cabreve$landmetrics
Area_unit<-as.character(conversion[1])
Area_conv<-as.numeric(conversion[2])
View(aggregations)
cabreve <- load.landSchema("C:\\Users\\benizar\\Dropbox\\article_cabreve\\load_data\\capbreu_load_tests_windows.yml")
bigTable<-cabreve$bigTable
conversion<-cabreve$landmetrics
Area_unit<-as.character(conversion[1])
Area_conv<-as.numeric(conversion[2])
View(aggregations)
cabreve <- load.landSchema("C:\\Users\\benizar\\Dropbox\\article_cabreve\\load_data\\capbreu_load_tests_windows.yml")
bigTable<-cabreve$bigTable
conversion<-cabreve$landmetrics
Area_unit<-as.character(conversion[1])
Area_conv<-as.numeric(conversion[2])
View(aggregations)
aggregations<-bigTable[bigTable$VarCategory != 'Limits', ]
aggregations<-dcast(aggregations,Landholder+Plot~Variable,value.var = "Value")
View(aggregations)
cabreve <- load.landSchema("C:\\Users\\benizar\\Dropbox\\article_cabreve\\load_data\\capbreu_load_tests_windows.yml")
bigTable<-cabreve$bigTable
View(bigTable)
conversion<-cabreve$landmetrics
Area_unit<-as.character(conversion[1])
Area_conv<-as.numeric(conversion[2])
aggregations<-bigTable[bigTable$VarCategory != 'Limits', ]
View(aggregations)
aggregations<-dcast(aggregations,Landholder+Plot~Variable,value.var = "Value")
View(aggregations)
aggregations$Area<-as.numeric(aggregations$Area)
View(aggregations)
aggregations$Area_m2<-aggregations$Area*Area_conv
View(aggregations)
View(aggregations)
attach(mtcars)
aggdata <-aggregate(mtcars, by=list(cyl,vs),
FUN=mean, na.rm=TRUE)
View(aggdata)
mtcars
aggregate(aggregations, by=aggregations$Level_1, FUN=sum, na.rm=TRUE)
aggregate(aggregations, by=list(aggregations$Level_1), FUN=sum, na.rm=TRUE)
aggregate(aggregations$Area_m2, by=list(aggregations$Level_1), FUN=sum, na.rm=TRUE)
aggregate(aggregations[,c(Area_m2], by=list(aggregations$Level_1), FUN=sum, na.rm=TRUE)
aggregate(aggregations[,c(Area_m2)], by=list(aggregations$Level_1), FUN=sum, na.rm=TRUE)
aggregate(aggregations[,c(aggregations$Area_m2)], by=list(aggregations$Level_1), FUN=sum, na.rm=TRUE)
aggregate(aggregations, by=list(aggregations$Level_1), FUN=sum, na.rm=TRUE)
aggregate(aggregations$Area_m2, by=list(aggregations$Level_1), FUN=sum, na.rm=TRUE)
summary.data.frame(aggregations)
summarydata<-summary.data.frame(aggregations)
bxp(summarydata)
boxplot(summarydata)
summarydata<-summary.data.frame(aggregations$Area)
aggregate(aggregations$Area_m2, by=list(aggregations$Level_1), FUN=sum, na.rm=TRUE)
plot<-aggregate(aggregations$Area_m2, by=list(aggregations$Level_1), FUN=sum, na.rm=TRUE)
boxplot(plot)
boxplot(plot$x)
plot(plot$x)
pie(plot$x, labels = plot$Group.1, main="Pie Chart of Countries")
View(plot)
L1Area<-aggregate(aggregations$Area, by=list(aggregations$Level_1,aggregations$Level_2), FUN=sum, na.rm=TRUE)
View(`L1Area`)
area_by_L1<-aggregate(aggregations$Area, by=list(aggregations$Level_1), FUN=sum, na.rm=TRUE)
areaIS_by_L1<-aggregate(aggregations$Area_m2, by=list(aggregations$Level_1), FUN=sum, na.rm=TRUE)
area_by_L1<-aggregate(aggregations$Area, by=list(aggregations$Level_1), FUN=sum, na.rm=TRUE,labels=Area_unit)
Area_unit
area_by_L1<-aggregate(aggregations$Area, by=list(aggregations$Level_1), FUN=sum, na.rm=TRUE,labels=Area_unit[1])
area_by_L1<-aggregate(aggregations$Area, by=list(aggregations$Level_1), FUN=sum, na.rm=TRUE,labels=c(Area_unit))
barplot(areaIS_by_L1,labels=areaIS_by_L1$Group.1)
barplot(c(areaIS_by_L1),labels=areaIS_by_L1$Group.1)
barplot(areaIS_by_L1$x,labels=areaIS_by_L1$Group.1)
barplot(areaIS_by_L1$x,xlabels=areaIS_by_L1$Group.1)
barplot(areaIS_by_L1$x)
barplot(areaIS_by_L1$x)
barplot(areaIS_by_L1)
table(mtcars$gear)
mtcars$gear
table(areaIS_by_L1)
as.table(area_by_L1)
barplot(t(as.matrix(areaIS_by_L1)), beside=TRUE)
barplot(t(as.matrix(areaIS_by_L1$x)), beside=TRUE)
barplot(areaIS_by_L1$x,labels=areaIS_by_L1$Group.1)
x <- t(areaIS_by_L1[-1])
colnames(x) <- areaIS_by_L1[, 1]
x <- t(areaIS_by_L1[-1])
barplot(x, beside = TRUE)
x <- t(areaIS_by_L1[-1])
colnames(x) <- areaIS_by_L1[, 1]
barplot(x, beside = TRUE)
x <- t(area_by_L1[-1])
colnames(x) <- areaIS_by_L1[, 1]
barplot(x, beside = TRUE)
barplot(x, beside = TRUE,las=2)
barplot(x, beside = TRUE,las=2,
cex.lab   = 0.65)
help(barplot)
barplot(x, beside = TRUE,las=2,cex.names = 0.65)
require(grDevices) # for colours
tN <- table(Ni <- stats::rpois(100, lambda = 5))
r <- barplot(tN, col = rainbow(20))
#- type = "h" plotting *is* 'bar'plot
lines(r, tN, type = "h", col = "red", lwd = 2)
barplot(tN, space = 1.5, axisnames = FALSE,
sub = "barplot(..., space= 1.5, axisnames = FALSE)")
mp <- barplot(VADeaths) # default
tot <- colMeans(VADeaths)
text(mp, tot + 3, format(tot), xpd = TRUE, col = "blue")
barplot(VADeaths, beside = TRUE,
col = c("lightblue", "mistyrose", "lightcyan",
"lavender", "cornsilk"),
legend = rownames(VADeaths), ylim = c(0, 100))
title(main = "Death Rates in Virginia", font.main = 4)
hh <- t(VADeaths)[, 5:1]
mybarcol <- "gray20"
mp <- barplot(hh, beside = TRUE,
col = c("lightblue", "mistyrose",
"lightcyan", "lavender"),
legend = colnames(VADeaths), ylim = c(0,100),
main = "Death Rates in Virginia", font.main = 4,
sub = "Faked upper 2*sigma error bars", col.sub = mybarcol,
cex.names = 1.5)
segments(mp, hh, mp, hh + 2*sqrt(1000*hh/100), col = mybarcol, lwd = 1.5)
stopifnot(dim(mp) == dim(hh))  # corresponding matrices
mtext(side = 1, at = colMeans(mp), line = -2,
text = paste("Mean", formatC(colMeans(hh))), col = "red")
# Bar shading example
barplot(VADeaths, angle = 15+10*1:5, density = 20, col = "black",
legend = rownames(VADeaths))
title(main = list("Death Rates in Virginia", font = 4))
# border :
barplot(VADeaths, border = "dark blue")
# log scales (not much sense here):
barplot(tN, col = heat.colors(12), log = "y")
barplot(tN, col = gray.colors(20), log = "xy")
# args.legend
barplot(height = cbind(x = c(465, 91) / 465 * 100,
y = c(840, 200) / 840 * 100,
z = c(37, 17) / 37 * 100),
beside = FALSE,
width = c(465, 840, 37),
col = c(1, 2),
legend.text = c("A", "B"),
args.legend = list(x = "topleft"))
barplot(x, beside = TRUE,angle = 45,cex.names = 0.65)
barplot(x, beside = TRUE,las=2,cex.names = 0.65)
x <- t(area_by_L1[-1])
colnames(x) <- areaIS_by_L1[, 1]
sort(x)
barplot(x, beside = TRUE,las=2,cex.names = 0.65)
sort(x)
x<-sort(x)
barplot(x, beside = TRUE,las=2,cex.names = 0.65)
x <- t(area_by_L1[-1])
View(x)
colnames(x) <- areaIS_by_L1[, 1]
View(x)
x<-sort(x)
x <- t(sort(area_by_L1[-1])
x <- t(sort(area_by_L1[-1])
x <- t(sort(area_by_L1[-1]))
sort(area_by_L1$x)
sort(area_by_L1)
area_by_L1 <- area_by_L1[order(-x),]
View(area_by_L1)
area_by_L1 <- area_by_L1[order(x),]
barplot(area_by_L1$x, beside = TRUE,las=2,cex.names = 0.65)
View(area_by_L1)
area_by_L1 <- area_by_L1[order(area_by_L1$Group.1),]
View(area_by_L1)
area_by_L1 <- area_by_L1[order(area_by_L1$x),]
View(area_by_L1)
barplot(area_by_L1$x, beside = TRUE,las=2,cex.names = 0.65)
barplot(area_by_L1$x, names.arg=area_by_L1$Group.1, beside = TRUE,las=2,cex.names = 0.65)
